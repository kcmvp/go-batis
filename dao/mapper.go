package dao

import (
	"encoding/xml"
	"errors"
	"fmt"
	"github.com/antchfx/xmlquery"
	"github.com/dgraph-io/ristretto"
	. "github.com/kcmvp/go-batis/dao/internal/syntax"
	"os"
	"path/filepath"
	"strings"
	"sync"
)


var maxCacheMaxEntries = 100

var (
	cacheOnce   sync.Once
	clauseCache *ristretto.Cache
	cacheMutex  sync.Mutex
)

type MapperType uint

const (
	Insert MapperType = iota
	Update
	Delete
	Find
	Search
)

func (mapperType MapperType) name() string {
	return [...]string{"insert", "update", "delete", "select", "select"}[mapperType]
}

type Mapper interface {
	Exec(arg interface{}) Result
}

func NewMapper(mType MapperType, name string /*, argType interface{}*/) Mapper {
	return & mapper{
		MapperType: mType,
		mapperName: name,
		//argType:    argType,
	}
}

type mapper struct {
	MapperType
	mapperName string
	//argType     interface{}
}

type Result interface {
	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId() (int64, error)

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected() (int64, error)

	// for query
	Rows() ([]interface{}, error)
}

func (m mapper) Exec(arg interface{}) Result {
	if clause, err := m.build(); err != nil {
		if sql, err := clause.Build(arg); err != nil {
			if len(clause.CacheKey) > 0 && len(clause.CacheName) > 0 {

			}
			panic(fmt.Sprintf("@todo %v", sql))
		}
	}
	return nil
}

// mapper file naming pattern is ${struct}Mapper.xml
func (mapper mapper) build() (*Clause, error) {

	cacheOnce.Do(func() {
		var err error
		clauseCache, err = ristretto.NewCache(&ristretto.Config{
			NumCounters: 10000,     //10K
			MaxCost:     100000000,  //100MB
			BufferItems: 64,
		})
		if err != nil {
			panic(err)
		}
	})

	if c, ok := clauseCache.Get(mapper.mapperName); ok {
		return c.(*Clause), nil
	}

	if entries := strings.Split(mapper.mapperName, "."); len(entries) == 2 {
		path, err := filepath.Abs(fmt.Sprintf("../mapper/%vMapper.xml", entries[0]))
		if err != nil {
			return nil, err
		}
		f, err := os.OpenFile(path, os.O_RDONLY, 0666)
		if err != nil {
			return nil, err
		}
		root, err := xmlquery.Parse(f)
		if err != nil {
			return nil, err
		}
		node := xmlquery.FindOne(root, fmt.Sprintf("//%v[@id='%v']", mapper.MapperType.name(), entries[1]))
		if node == nil {
			return nil, errors.New("can't find the node")
		}
		var c Clause
		xmlNode := node.OutputXML(true)
		if xml.Unmarshal([]byte(xmlNode), &c) != nil {
			defer func() {
				clauseCache.Set(mapper.mapperName, &c,0)
			}()
		}
		defer func() {
			f.Close()
		}()
		return &c, nil

	} else {
		return nil, errors.New("can't find the dao")
	}

}
