package dao

import (
	"encoding/xml"
	"errors"
	"fmt"
	"github.com/antchfx/xmlquery"
	"github.com/go-batis/dao/internal/cache"
	. "github.com/go-batis/dao/internal/syntax"
	"os"
	"path/filepath"
	"strings"
)

type MapperType uint

const (
	Insert MapperType = iota
	Update
	Delete
	Find
	Search
)

func (mapperType MapperType) name() string {
	return [...]string{"insert", "update", "delete", "select", "select"}[mapperType]
}




type Mapper interface {
	Exec(arg interface{}) Result
}

func NewMapper(mType MapperType, name string /*, argType interface{}*/) Mapper {
	return &mapper{
		MapperType: mType,
		mapperName: name,
		//argType:    argType,
	}
}

type mapper struct {
	MapperType
	mapperName string
	//argType     interface{}
}

type Result interface {
	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId() (int64, error)

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected() (int64, error)

	// for query
	Rows() ([]interface{}, error)
}

func (m mapper) Exec(arg interface{}) Result {
	if clause, err := m.getMapper(); err != nil {
		if sql, err := clause.Build(arg); err != nil {
			if len(clause.CacheKey) > 0 && len(clause.CacheName) > 0 {

			}
			panic(fmt.Sprintf("@todo %v", sql))
		}
	}
	return nil
}

// mapper file naming pattern is ${struct}Mapper.xml
func (mapper mapper) getMapper() (Clause, error) {

	if c, err := cache.SysCache.Get(mapper.mapperName); err != nil {
		if c, ok := c.(Clause); ok {
			return c, nil
		}
	}

	if entries := strings.Split(mapper.mapperName, "."); len(entries) == 2 {
		path, err := filepath.Abs(fmt.Sprintf("../mapper/%vMapper.xml", entries[0]))
		if err != nil {
			return Clause{}, err
		}
		f, err := os.OpenFile(path, os.O_RDONLY, 0666)
		if err != nil {
			return Clause{}, err
		}
		root, err := xmlquery.Parse(f)
		if err != nil {
			return Clause{}, err
		}
		node := xmlquery.FindOne(root, fmt.Sprintf("//%v[@id='%v']", mapper.MapperType.name(), entries[1]))
		if node == nil {
			return Clause{}, errors.New("can't find the node")
		}
		var c Clause
		if xml.Unmarshal(nil, &c) != nil {
			defer func() {
				cache.SysCache.Put(mapper.mapperName, c)
			}()
		}
		return c, nil

	} else {
		return Clause{}, errors.New("can't find the dao")
	}

}
